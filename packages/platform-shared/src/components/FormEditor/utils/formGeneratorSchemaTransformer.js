/**
 * Copyright (c) 2024 ForgeRock. All rights reserved.
 *
 * This software may be modified and distributed under the terms
 * of the MIT license. See the LICENSE file for details.
 */
import { set } from 'lodash';
import i18n from '@/i18n';

/**
 * return the type of the field for the form generator based on the type of the field in the form builder
 * @param {string} formBuilderType - the type of the field in the form builder
 * @returns {string} the type of the field for the form generator
 */
function getFormGeneratorType(formBuilderType) {
  const formBuilderToFormGeneratorTypes = {
    text: 'string',
    checkbox: 'boolean',
  };

  return formBuilderToFormGeneratorTypes[formBuilderType] || formBuilderType;
}

/**
 * return the column classes for the field based on the layout information
 * @param {Object} layout - the layout information of the field
 * @param {number} layout.columns - the number of columns the field occupies
 * @param {number} layout.offset - the number of columns the field is offset by
 * @returns {string} the column classes for the field
 */
function getColumnClasses(layout) {
  return `col-md-${layout.columns} offset-md-${layout.offset}`;
}

/**
 * Retrieves the label for an optional property.
 * @param {object} propSchema - The schema of the property.
 * @returns {string} - The label for the property.
 */
function getOptionalPropLabel(propSchema) {
  if (!propSchema.label) return '';
  // checkboxes cannot be required/optional
  if (propSchema.type === 'checkbox' || propSchema.validation?.required === true) return propSchema.label;
  return i18n.global.t('common.optionalFieldTitle', { fieldTitle: propSchema.label });
}

/**
 * Sets the default value for a field in the schema.
 *
 * @param {Object} field - The field object.
 * @param {Object} schemaField - The schema field object.
 */
function setDefaultSchemaFieldValue(field, schemaField) {
  switch (field.type) {
    case 'multiselect':
      field.defaultValue = schemaField.options
        ?.filter((option) => (option.selectedByDefault))
        ?.map((option) => option.value) || [];
      break;
    case 'select':
      field.defaultValue = schemaField.options
        ?.find((option) => (option.selectedByDefault))?.value || '';
      break;
    default:
      break;
  }
}

/**
 * Transforms a schema generated by the {@link FormEditor} component into a schema that can be used by the {@link FormGenerator} component.
 * This transformation ensures that the fields are organized into rows, with a maximum of 12 columns per row.
 * @param {Array} schema - The schema generated by the FormEditor component. Each element in the array represents a field with specific properties and layout information.
 * @param {boolean} readOnly - A boolean value that indicates whether the form is read-only.
 * @param {boolean} includeDefaults - Whether to include default values for fields.
 * @returns {Array} A transformed schema that is organized into rows for the FormGenerator component. Each row contains an array of field objects with their respective properties and layout information.
 *
 * @see FormEditor
 * @see FormGenerator
 */
// eslint-disable-next-line import/prefer-default-export
export function transformSchemaToFormGenerator(schema, readOnly = false, includeDefaults = false) {
  return schema.reduce((schemaFormGenerator, schemaField) => {
    // Initialize the schemaFormGenerator with an empty row if it is empty
    if (!schemaFormGenerator.length) {
      schemaFormGenerator.push([]);
    }

    // Get the last row in the schemaFormGenerator
    let lastRow = schemaFormGenerator[schemaFormGenerator.length - 1];

    // Calculate the total columns count of the current row
    const columnsCount = lastRow.reduce((acc, field) => acc + field.layout.columns, 0);

    // If adding the current field exceeds 12 columns, start a new row
    if (columnsCount + schemaField.layout.columns + schemaField.layout.offset > 12) {
      lastRow = [];
      schemaFormGenerator.push(lastRow);
    }

    // Add the current field to the last row
    const field = {
      ...schemaField,
      disabled: readOnly,
      type: getFormGeneratorType(schemaField.type),
      columnClass: getColumnClasses(schemaField.layout),
      label: getOptionalPropLabel(schemaField),
    };

    // the form generator component expects the options to be an array of objects with value and text properties
    if (schemaField.type === 'multiselect' || schemaField.type === 'select') {
      field.options = schemaField.options?.map((option) => ({
        value: option.value,
        text: option.label,
      })) || [];
    }

    if (includeDefaults) setDefaultSchemaFieldValue(field, schemaField);
    else if (field.type === 'multiselect') field.defaultValue = [];
    else delete field.defaultValue;

    lastRow.push(field);

    return schemaFormGenerator;
  }, []);
}

/**
 * Generates the initial model for a form based on the given schema.
 * This returns an object with keys that correspond to the model paths of the fields in the schema.
 * Adds default values for fields if the includeDefaults parameter is set to true.
 * @param {Array} schema - The schema defining the form fields.
 * @param {boolean} [includeDefaults=false] - Whether to include default values for fields.
 * @returns {Object} - The initial model object for the form.
 */
export function getInitialModel(schema, includeDefaults = false) {
  const updatedModel = {};
  schema.forEach((field) => {
    let value;
    switch (field.type) {
      case 'string':
      case 'textarea':
        value = includeDefaults
          ? field.defaultValue || ''
          : '';
        set(updatedModel, field.model, value);
        break;
      case 'select':
        value = includeDefaults
          ? field.options?.find((option) => (option.selectedByDefault))?.value || ''
          : '';
        set(updatedModel, field.model, value);
        break;
      case 'multiselect':
        value = includeDefaults
          ? field.options?.filter((option) => (option.selectedByDefault))?.map((option) => (option.value))
          : [];
        set(updatedModel, field.model, value);
        break;
      case 'checkbox':
        value = includeDefaults
          ? field.defaultValue || false
          : false;
        set(updatedModel, field.model, value);
        break;
      default:
        break;
    }
  });
  return updatedModel;
}
